/*
******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 9.3.0   2023-01-05

The MIT License (MIT)
Copyright (c) 2019 STMicroelectronics

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

******************************************************************************
*/

/* Includes */
#include "stm32f4xx.h"
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "croutine.h"
#include "semphr.h"


#include "rcc.h"
#include "gpio.h"
#include "spi.h"

#include "SPI_flash.h"
#include "lfs_config.h"
#include "w5500.h"
#include "dhcp.h"
#include "socket.h"
#include "httpServer.h"
#include "ethernet_init.h"

#include "mb.h"
#include "mbutils.h"

#include "web_pages.h"
#include "data_types.h"
#include "definition.h"
#include "http_app.h"
#include "MQTTClient.h"
#include "stdio.h"
#include "mqtt_gen_strings.h"
#include "mqtt_app.h"
/* Private macro */
/* Private variables */
lfs_t lfs;
lfs_file_t file;
struct lfs_config cfg;

SemaphoreHandle_t	SPI2mutex, LFSmutex, SocketMutex, DNSMutex; // Semaphore for SPI interfase. Enthernet chip & flash.
TaskHandle_t		Display, Internet, OneSecond, WachDog, Col_and_Input, Internet_modbus, Internet_httpd, Internet_MQTT, RW_settings, RAM_debug_task_handler; //Task handler for get info about task
xQueueHandle		runnTimeQ, EthernetInfoQ, bootCountQ, discreteInputsQ, disctereOutputsReadQ, \
						disctereOutputsWriteQ, MQTTCredQ, ModbusTCPparamsQ, HAParamsQ;

/* Private function prototypes */

/* Private functions */
void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed portCHAR *pcTaskName ) {

    ( void ) pcTaskName;
    ( void ) pxTask;

	taskDISABLE_INTERRUPTS(); // game over

  for( ;; );
}

void vApplicationMallocFailedHook(){

	taskDISABLE_INTERRUPTS(); // game over
	for( ;; );
}

void vApplicationIdleHook( void ){
}

void vApplicationTickHook( void ){
	mqtt_1ms_tik();
}

void SPI2TakeSemaphore(void){
	xSemaphoreTake(SPI2mutex, portMAX_DELAY);
}

void SPI2GiveSemaphore(void){
	xSemaphoreGive(SPI2mutex);
}

int LFSTakeSemaphore(const struct lfs_config *c){
	xSemaphoreTake(LFSmutex, portMAX_DELAY);
	return 0;
}

int LFSGiveSemaphore(const struct lfs_config *c){
	xSemaphoreGive(LFSmutex);
	return 0;
}

int SocketTakeSemaphore(void){
	xSemaphoreTake(SocketMutex, portMAX_DELAY);
	return 0;
}

int SocketGiveSemaphore(void){
	xSemaphoreGive(SocketMutex);
	return 0;
}

uint8_t read_coils_state(void){
	uint8_t data;
	xQueuePeek(disctereOutputsReadQ ,&data,0);
	return data;
}

void write_coils_state(uint8_t data){
	xQueueOverwrite(disctereOutputsWriteQ, (void *)&data);
}

void vRead_and_write_settings (void *pvParameters){
	/* Private variables */
	uint8_t lfs_file_buf[LFS_BUF_SIZE]; 					// buffer for file W/R
	uint8_t lfs_read_buf[LFS_BUF_SIZE];						// read from flash buffer
	uint8_t lfs_write_buf[LFS_BUF_SIZE];					// write to flash buffer
	uint8_t lfs_lookahead_buff[LFS_BUF_SIZE];

	static struct lfs_file_config fileConf;
	memset(&fileConf, 0, sizeof(struct lfs_file_config));
	fileConf.buffer = lfs_file_buf;  						// use the static buffer
	fileConf.attr_count = 0;
	struct lfs_info 	file_info;
	MQTT_cred_struct 	MQTT_credentials;					// MQTT settings
	//Home_assist_struct 	HA_parameters;					// Home Assistant specific settings
	ModBusTCP_struct	ModBusTCP_parameters;				// MobBusTCP settins
	int err;

	io_fs_init(lfs_read_buf, lfs_write_buf, lfs_lookahead_buff, LFS_BUF_SIZE);

	err = lfs_mount(&lfs, &cfg);
	if (err) {
		lfs_format(&lfs, &cfg);
		err = lfs_mount(&lfs, &cfg);
	}

	if ((0 > lfs_stat(&lfs, "MQTT_credentials", &file_info)) || (file_info.size == 0) ){
		//set defualt parameters
		MQTT_credentials.save		= 0;
		MQTT_credentials.enable		= 0;
		MQTT_credentials.ip[0] 		= 0;
		MQTT_credentials.ip[1] 		= 0;
		MQTT_credentials.ip[2] 		= 0;
		MQTT_credentials.ip[3] 		= 0;
		MQTT_credentials.port 		= 0;
		MQTT_credentials.login[0] 	= 0;
		MQTT_credentials.pass[0] 	= 0;
	}else{
		lfs_file_opencfg(&lfs, &file, "MQTT_credentials", LFS_O_RDONLY | LFS_O_CREAT, &fileConf);
		lfs_file_read(&lfs, &file, &MQTT_credentials, sizeof(MQTT_credentials));
		lfs_file_close(&lfs, &file);
	}

	if ((0 > lfs_stat(&lfs, "ModbusTCP_params", &file_info)) || (file_info.size == 0) ){
		//set default parameters
		ModBusTCP_parameters.save	= 0;
		ModBusTCP_parameters.enable	= 0;
	}else{
		lfs_file_opencfg(&lfs, &file, "ModbusTCP_params", LFS_O_RDONLY | LFS_O_CREAT, &fileConf);
		lfs_file_read(&lfs, &file, &ModBusTCP_parameters, sizeof(ModBusTCP_parameters));
		lfs_file_close(&lfs, &file);
	}


	xQueueOverwrite(MQTTCredQ,			(void *)&MQTT_credentials);
	xQueueOverwrite(ModbusTCPparamsQ,	(void *)&ModBusTCP_parameters);

	while (1){

		xQueuePeek(MQTTCredQ,		&MQTT_credentials,		0);
		xQueuePeek(ModbusTCPparamsQ,&ModBusTCP_parameters,	0);

		if (MQTT_credentials.save){
			MQTT_credentials.save = 0;
			err = lfs_file_opencfg(&lfs, &file, "MQTT_credentials", LFS_O_RDWR | LFS_O_CREAT | LFS_O_TRUNC, &fileConf);
			err = lfs_file_write(&lfs, &file, &MQTT_credentials, sizeof(MQTT_credentials));
			err = lfs_file_close(&lfs, &file);
			xQueueOverwrite(MQTTCredQ, (void *)&MQTT_credentials);
		}

		if (ModBusTCP_parameters.save){
			ModBusTCP_parameters.save = 0;
			err = lfs_file_opencfg(&lfs, &file, "ModbusTCP_params", LFS_O_RDWR | LFS_O_CREAT | LFS_O_TRUNC, &fileConf);
			err = lfs_file_write(&lfs, &file, &ModBusTCP_parameters, sizeof(ModBusTCP_parameters));
			err = lfs_file_close(&lfs, &file);
			xQueueOverwrite(ModbusTCPparamsQ,	(void *)&ModBusTCP_parameters);
		}
		vTaskDelay(delay0_5s);
	}
	vTaskDelete(NULL);
}
/*
 * Main internet task to serve DHCP needs,
 * cable connection status and
 * other background tasks.
 */
void vInternetMainTask(void *pvParameters){

	uint8_t 				DHCP_DATABUF[SOCKET_BUFF_SIZE];
	wiz_NetInfo 			NetInfo;
	Ethernet_info_struct	EthernetInfo;
	int 					i;


	w5500_lib_init(&NetInfo);
	w5500_delay_cb(vTaskDelay);
	reg_wizchip_spi_cbfunc(SPI_ReceiveByte, SPI_SendByte);
	reg_wizchip_cs_cbfunc(EthernetChipSelect, EthernetChipDeselect);
	reg_dhcp_cbfunc(Callback_IPAssigned, Callback_IPAssigned, Callback_IPConflict);
	reg_dhcp_delay_cbfunc(vTaskDelay);

	NetInfo.mac[0]	= 0x40;
	NetInfo.mac[1]	= 0x08;
	NetInfo.mac[2]	= *(uint8_t*)(UID_BASE);
	NetInfo.mac[3]	= *(uint8_t*)(UID_BASE + 0x01);
	NetInfo.mac[4]	= *(uint8_t*)(UID_BASE + 0x02);
	NetInfo.mac[5]	= *(uint8_t*)(UID_BASE + 0x03);

	for(i = 0; i < 6; i++){
		EthernetInfo.mac[i] = NetInfo.mac[i];
	}

	//todo read from flash ip, netmask, dns, gateway

	NetInfo.ip[0]	= 0, NetInfo.ip[1] 	= 0, NetInfo.ip[2] 	= 0, NetInfo.ip[3] 	= 0;
	NetInfo.sn[0] 	= 0, NetInfo.sn[1] 	= 0, NetInfo.sn[2] 	= 0, NetInfo.sn[3] 	= 0;
	NetInfo.gw[0] 	= 0, NetInfo.gw[1] 	= 0, NetInfo.gw[2] 	= 0, NetInfo.gw[3] 	= 0;
	NetInfo.dns[0] 	= 0, NetInfo.dns[1] = 0, NetInfo.dns[2] = 0, NetInfo.dns[3] = 0;
	NetInfo.dhcp 	= NETINFO_DHCP;

	/*---------------------DEBUG----------------------
	NetInfo.ip[0]	= 10,	NetInfo.ip[1] 	= 0,	NetInfo.ip[2] 	= 20, 	NetInfo.ip[3] 	= 11;
	NetInfo.sn[0] 	= 255,	NetInfo.sn[1] 	= 255,	NetInfo.sn[2] 	= 255, 	NetInfo.sn[3] 	= 0;
	NetInfo.gw[0] 	= 10, 	NetInfo.gw[1] 	= 0,	NetInfo.gw[2] 	= 20, 	NetInfo.gw[3] 	= 254;
	NetInfo.dns[0] 	= 8, 	NetInfo.dns[1] 	= 8,	NetInfo.dns[2] 	= 8,	NetInfo.dns[3] 	= 8;
	NetInfo.dhcp 	= NETINFO_STATIC;*/
	/*---------------------DEBUG----------------------*/

	vTaskDelay(delay0_5s);
	while (1){
		EthernetInfo.dhcp = NetInfo.dhcp;
		EthernetInfo.link = 0;

		if (w5500_init() != 0)continue; //try from begin in fail case
		vTaskDelay(delay0_5s);
 		setSHAR(NetInfo.mac);			//set mac address

		if (NetInfo.dhcp == NETINFO_DHCP){
			DHCP_init(DHCP_SOCKET, DHCP_DATABUF);
			//todo DNS_init();
		}else{
			network_init();
			set_ip_aasigned();
		}
		while(1){

			if (NetInfo.dhcp == NETINFO_DHCP){

			}
xSemaphoreTake(SocketMutex, portMAX_DELAY);
			dhcp_rutine();

			if (!link_status()){
				NetInfo.ip[0]	= 0, NetInfo.ip[1] 	= 0, NetInfo.ip[2] 	= 0, NetInfo.ip[3] 	= 0;
				NetInfo.sn[0] 	= 0, NetInfo.sn[1] 	= 0, NetInfo.sn[2] 	= 0, NetInfo.sn[3] 	= 0;
				NetInfo.gw[0] 	= 0, NetInfo.gw[1] 	= 0, NetInfo.gw[2] 	= 0, NetInfo.gw[3] 	= 0;
				NetInfo.dns[0] 	= 0, NetInfo.dns[1] = 0, NetInfo.dns[2] = 0, NetInfo.dns[3] = 0;

xSemaphoreGive(SocketMutex);

				for(i = 0; i < 4; i++){
					EthernetInfo.ip[i] 	= NetInfo.ip[i];
					EthernetInfo.sn[i] 	= NetInfo.sn[i];
					EthernetInfo.gw[i] 	= NetInfo.gw[i];
					EthernetInfo.dns[i] = NetInfo.dns[i];
				}
				EthernetInfo.link 	= 0;
				xQueueOverwrite(EthernetInfoQ, (void *)&EthernetInfo);
				break;
			}

			for(i = 0; i < 4; i++){//todo rewrite for get info from dhcp calbac
				EthernetInfo.ip[i] 	= NetInfo.ip[i];
				EthernetInfo.sn[i] 	= NetInfo.sn[i];
				EthernetInfo.gw[i] 	= NetInfo.gw[i];
				EthernetInfo.dns[i] = NetInfo.dns[i];
			}

			EthernetInfo.link 		= 1;
			EthernetInfo.speed 		= link_speed();
			EthernetInfo.duplex 	= link_duplex();
			EthernetInfo.lease_s	= getDHCPLeasetime();

xSemaphoreGive(SocketMutex);
			//ctlnetwork(CN_GET_NETINFO, &NetInfo);

			if (NetInfo.ip[0]== 0){
				vTaskDelay(delay1s);
				continue;
			}

			xQueueOverwrite(EthernetInfoQ, (void *)&EthernetInfo);
			vTaskDelay(delay1s);
		}
	}
	vTaskDelete(NULL);
}

void vOneSecondTikTask (void *pvParameters){
	uint32_t seconds;
	seconds = 0;
	Ethernet_info_struct	EthernetInfo; //todo delete after test

	while(1){
		xQueueOverwrite(runnTimeQ, (void *) &seconds);
		seconds++ ;
		DHCP_time_handler();
		DNS_time_handler();
		httpServer_time_handler();

		//httpServer_time_handler();
		vTaskDelay(delay1s);

		xQueuePeek(EthernetInfoQ,  &EthernetInfo,0);
	}
	vTaskDelete(NULL);
}

void vCol_and_Input (void *pvParameters){

	uint16_t pinCoils[] = {coil1_PIN, coil2_PIN, coil3_PIN};
	uint16_t pinInputs[] = {input1_PIN, input2_PIN, input3_PIN};
	uint8_t pinCoils_r;
	uint8_t pinCoils_w = 0 ;
	uint8_t pinInputs_r;
	uint8_t i;

	xQueueOverwrite(disctereOutputsWriteQ, (void *)&pinCoils_w);

	while (1){
		//---------------New Way -------------------------------------

		xQueuePeek(disctereOutputsWriteQ, &pinCoils_w,0);
		//todo write coils
		for( i = 0; i < REG_COILS_NREGS; i++ ){
			if (pinCoils_w & (0b00000001 << i)){
				GPIO_WriteBit(coils_GPIO_PORT, pinCoils[i], Bit_SET);
			}else{
				GPIO_WriteBit(coils_GPIO_PORT, pinCoils[i], Bit_RESET);
			}
		}
		//read coils status
		pinCoils_r = 0;
		for( i = 0; i < REG_COILS_NREGS; i++ ){
			pinCoils_r = pinCoils_r | GPIO_ReadOutputDataBit(coils_GPIO_PORT, pinCoils[i]) << i;
		}

		xQueueOverwrite(disctereOutputsReadQ, (void *)&pinCoils_r);

		//read inputs status
		pinInputs_r = 0;
		for (i = 0; i < REG_DISCRETE_NREGS; i++ ){
			pinInputs_r = pinInputs_r | GPIO_ReadInputDataBit(inputs_GPIO_PORT, pinInputs[i]) << i;
		}

		xQueueOverwrite(discreteInputsQ, (void *)&pinInputs_r);
		vTaskDelay(100);

	}
	vTaskDelete(NULL);
}

void vInternetModbusTCP (void *pvParameters){
	Ethernet_info_struct	EthernetInfo;
	uint8_t 				sn=0;
	ModBusTCP_struct		ModBusTCP_parameters;				// MobBusTCP settins

	while (1){
		vTaskDelay(1000);
		xQueuePeek(EthernetInfoQ ,&EthernetInfo,0);
		if ((EthernetInfo.link != ETH_LINK_UP) || (assigned_ip() != true)) continue;
xSemaphoreTake(SocketMutex, portMAX_DELAY);
		if (eMBTCPInit(MODBUS_PORT) != MB_ENOERR) continue;

		if (eMBEnable() != MB_ENOERR) continue;
xSemaphoreGive(SocketMutex);
		while(1){
			vTaskDelay(delay0_2s);
			xQueuePeek(ModbusTCPparamsQ,&ModBusTCP_parameters,	0);
			if (ModBusTCP_parameters.enable == 0) continue;
			xQueuePeek(EthernetInfoQ ,&EthernetInfo,0);
			if ((EthernetInfo.link == ETH_LINK_UP) && (assigned_ip() == true)){
xSemaphoreTake(SocketMutex, portMAX_DELAY);
				for( sn=START_MODBUS_SOCKET ; sn<=END_MODBUS_SOCKET ; sn++ ){
					modbus_tcps(sn,MODBUS_PORT);
				}
xSemaphoreGive(SocketMutex);
			}else{
				break;
			}

		}
	}
	vTaskDelete(NULL);
}

void vInternetHTTPd (void *pvParameters){

	Ethernet_info_struct	EthernetInfo;
	uint8_t socknumlist[] = {HTTP_SERVER_SOCKET};
	uint8_t http_buffer_rx[2048];
	uint8_t http_buffer_tx[2048];

	httpServer_init(http_buffer_tx, http_buffer_rx, HTTP_SERVER_NSOCKETS, socknumlist);		// Tx/Rx buffers (2 kB) / The number of W5500 chip H/W sockets in use
	reg_external_post_cgi_processor(http_post_cgi_processor);
	http_parse_params_init(MQTTCredQ,		MQTT);
	http_parse_params_init(HAParamsQ,		HA);
	http_parse_params_init(ModbusTCPparamsQ,ModBusTCP);

	// Index page and netinfo / base64 image demo
	reg_httpServer_webContent((uint8_t *)"index.html", (uint8_t *)index_page);						// index.html 		: Main page example
	reg_httpServer_webContent((uint8_t *)"settings_MQTT.html", (uint8_t *)conf_page_mqtt);		// settings_MQTT.html 	: Network information example page
	reg_httpServer_webContent((uint8_t *)"settings_MODBUS_TCP.html", (uint8_t *)settings_ModbusTCP_page);		// settings_MQTT.html 	: Network information example page

	vTaskDelay(delay5s);

	while(1){
		xQueuePeek(EthernetInfoQ ,&EthernetInfo,0);
		if ((EthernetInfo.link == ETH_LINK_UP) && (assigned_ip() == true)){
xSemaphoreTake(SocketMutex, portMAX_DELAY);
			httpServer_run(0); // HTTP Server handler
xSemaphoreGive(SocketMutex);
		}
		vTaskDelay(250);
	}
	vTaskDelete(NULL);

}

void vInternet_MQTT(void *pvParameters){

	MQTT_cred_struct 		MQTT_credentials;	//MQTT global variables
	Home_assist_struct 		HA_parameters;		//Home Assistant params (topik)
	unsigned char 			targetMQTThostname[MAX_DOMAIN_NAME] = {"eu-central-1.console.aws.amazon.com"}; //mqtt server hostname
	unsigned char 			MQTT_SEND_BUF[MQTT_TEMP_BUF];
	unsigned char 			MQTT_READ_BUF[MQTT_TEMP_BUF];
	char		 			buf_payload[512];
	char 					buf_topik[TOPIK_MAX_LEN];
	uint8_t 				inputStatus, inputStatusOld;
	uint8_t					coilStatus, coilStatusOld;
	uint32_t 				runn_sec=0;
	Ethernet_info_struct	EthernetInfo;
	uint32_t				input_next_update_time = 0;
	uint32_t				coils_next_update_time = 0;

	init_mqtt_call_mutex(SocketTakeSemaphore, SocketGiveSemaphore);
	init_mqtt_call_rw_coils(read_coils_state, write_coils_state);

	while (1){
		input_next_update_time = 0;
		coils_next_update_time = 0;

		vTaskDelay(delay1s);
		xQueuePeek(EthernetInfoQ,  &EthernetInfo, 0);
		if ((EthernetInfo.link != ETH_LINK_UP) || (assigned_ip() != true)){
			continue;
		}
		xQueuePeek(MQTTCredQ, &MQTT_credentials, 0);

		while (MQTT_credentials.enable == 0){
			vTaskDelay(delay1s);
			xQueuePeek(MQTTCredQ, &MQTT_credentials, 0);
		}

		if (!MQTT_credentials.enable) continue;
		mqtt_client_init(&EthernetInfo, &MQTT_credentials, MQTT_SEND_BUF, MQTT_TEMP_BUF, MQTT_READ_BUF, MQTT_TEMP_BUF);
		if (mqtt_client_connect() < 0) continue;
		if (mqtt_client_reg_dev_on_home_assist() != 0) continue;
		if (mqtt_subscrabe_on_topik() != 0) continue;

		while (1){
			vTaskDelay(delay0_1s);
			xQueuePeek(MQTTCredQ, &MQTT_credentials, 0);
			if ((MQTT_credentials.enable == 0)||(MQTT_credentials.save == 1)) break;

			xQueuePeek(EthernetInfoQ,  &EthernetInfo, 0);
			if ((EthernetInfo.link != ETH_LINK_UP) || (assigned_ip() != true)) break;

			xQueuePeek(runnTimeQ,  &runn_sec,0);
			xQueuePeek(discreteInputsQ, &inputStatus, 0);

			if ( (inputStatus != inputStatusOld) || (runn_sec > input_next_update_time)){

				convert_bint_to_JSON_statusIO( buf_payload, inputStatus, "ON" , "OFF" , "INP", 3);
				generate_status_topik(buf_topik, INPUT_TOPIK);
				if (send_data_to_topik(buf_topik, buf_payload) != 0 ) break;
				input_next_update_time 	= runn_sec + UPDATE_MQTT_PARAM_INTERVAL;
				inputStatusOld 			= inputStatus;

			}

			xQueuePeek(disctereOutputsReadQ , &coilStatus, 0);
			if( (coilStatus != coilStatusOld) || (runn_sec > coils_next_update_time) ){

				convert_bint_to_JSON_statusIO( buf_payload, coilStatus, "ON" , "OFF" , "SW", 3);
				generate_status_topik(buf_topik, OUTPUT_TOPIK);
				if (send_data_to_topik(buf_topik, buf_payload) != 0 ) break;
				coils_next_update_time 	= runn_sec + UPDATE_MQTT_PARAM_INTERVAL;
				coilStatusOld			= coilStatus;

			}

			if (mqtt_handler() != 0) break;

		}

	}
	vTaskDelete(NULL);
}

void vDebug_RAM_usage(void *pvParameters){
	int FreeHeapSize = 0;
	UBaseType_t HWM_RW_settings, HWM_OneSecond, HWM_Col_and_Input, HWM_Internet, HWM_Internet_modbus, HWM_Internet_httpd, HWM_Internet_MQTT, HWM_RAM_debug_task_handler ;

	while(1){

		FreeHeapSize 				= xPortGetFreeHeapSize();
		HWM_RW_settings 			= uxTaskGetStackHighWaterMark( RW_settings );
		HWM_OneSecond 				= uxTaskGetStackHighWaterMark( OneSecond );
		HWM_Col_and_Input 			= uxTaskGetStackHighWaterMark( Col_and_Input );
		HWM_Internet 				= uxTaskGetStackHighWaterMark( Internet );
		HWM_Internet_modbus 		= uxTaskGetStackHighWaterMark( Internet_modbus );
		HWM_Internet_httpd			= uxTaskGetStackHighWaterMark( Internet_httpd );
		HWM_Internet_MQTT 			= uxTaskGetStackHighWaterMark( Internet_MQTT );
		HWM_RAM_debug_task_handler 	= uxTaskGetStackHighWaterMark( NULL );

		vTaskDelay(delay1s);
	}
	vTaskDelete(NULL);
}

//Работает корректно
eMBErrorCode eMBRegHoldingCB (UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs, eMBRegisterMode eMode)
{
	// Статус ошибки
	eMBErrorCode eStatus = MB_ENOERR;
	//Компенсировать
	int16_t iRegIndex;
	//Значение регистров
	uint16_t usRegHoldingBuf[REG_HOLDING_NREGS] = {0x147b,0x3f8e,0x147b,0x400e,0x1eb8,0x4055,0x147b,0x408e,0x39,0x67};


	// Оцениваем, находится ли регистр в диапазоне
	if (((int16_t) usAddress >= REG_HOLDING_START) && (usAddress + usNRegs <= REG_HOLDING_START + REG_HOLDING_NREGS))
	{
		// Рассчитываем смещение
		iRegIndex = (int16_t) (usAddress-REG_HOLDING_START);

		switch  (eMode)
		{
		// Считываем функцию обработки
		case MB_REG_READ:
			while (usNRegs> 0)
			{
				* pucRegBuffer ++ = (uint8_t) (usRegHoldingBuf [iRegIndex] >> 8);
				* pucRegBuffer ++ = (uint8_t) (usRegHoldingBuf [iRegIndex] & 0xFF);
				iRegIndex ++;
				usNRegs--;
			}
			break;

		// Записываем функцию обработки
		case MB_REG_WRITE:
			while (usNRegs> 0)
			{
				usRegHoldingBuf [iRegIndex] = * pucRegBuffer ++ << 8;
				usRegHoldingBuf [iRegIndex] |= * pucRegBuffer ++;
				iRegIndex ++;
				usNRegs--;
			}
			break;
		}
	}
	else
	{
		// Возвращаем статус ошибки
		eStatus = MB_ENOREG;
	}
	return eStatus;
}

//есть проблемы
eMBErrorCode eMBRegDiscreteCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNDiscrete){
	// Статус ошибки
	eMBErrorCode eStatus = MB_ENOERR;
	uint8_t Input_status;

	usAddress --; /* to c-style address */

	// Оцениваем, находится ли регистр в диапазоне
	if (((int16_t) usAddress >= REG_DISCRETE_START) && (usAddress + usNDiscrete <= REG_DISCRETE_START + REG_DISCRETE_NREGS))
	{
		xQueuePeek(discreteInputsQ, &Input_status, 0); // получаем состояние входов
		// Считываем функцию обработки
		for (int i = 0; i < usNDiscrete; i++) {
			UCHAR rbit = xMBUtilGetBits( &Input_status, usAddress+i, 1 );
			xMBUtilSetBits( pucRegBuffer, i, 1, rbit );
		}
	}
	else
	{
		// Возвращаем статус ошибки
		eStatus = MB_ENOREG;
	}
	return eStatus;
}

eMBErrorCode eMBRegCoilsCB(UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNCoils, eMBRegisterMode eMode)
{
    usAddress --; /* to c-style address */
    //todo считывание и запись состояния реле в очередь и из очереди
    uint8_t CoilStatus_new;
    /* check if we away of table size */
    if (((int16_t) usAddress >= REG_COILS_START) && (usAddress + usNCoils <= REG_COILS_START + REG_COILS_NREGS))
    //if (usAddress + usNCoils > TABLE_CS_SIZE)
    {
		switch (eMode)
		{
			case MB_REG_WRITE:

				xQueuePeek(disctereOutputsReadQ ,&CoilStatus_new,0);

				for (int i = 0; i < usNCoils; i++) {
					UCHAR wbit = xMBUtilGetBits(pucRegBuffer, i, 1 );
					//xMBUtilSetBits( &CoilsStatus, usAddress+i, 1, wbit );
					xMBUtilSetBits( &CoilStatus_new, usAddress+i, 1, wbit );
				}

				xQueueOverwrite(disctereOutputsWriteQ, (void *)&CoilStatus_new);

				break;
			case MB_REG_READ:

				xQueuePeek(disctereOutputsReadQ ,&CoilStatus_new,0);

				for (int i = 0; i < usNCoils; i++) {
					UCHAR rbit = xMBUtilGetBits( &CoilStatus_new, usAddress+i, 1 );
					xMBUtilSetBits( pucRegBuffer, i, 1, rbit );
				}
				break;
			default:
				return MB_EINVAL;
		}
		return MB_ENOERR;
    }
    else
    {
    	 return MB_ENOREG;
    }
}

eMBErrorCode eMBRegInputCB(UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs )
{
    eMBErrorCode    eStatus = MB_ENOERR;
    USHORT          iRegIndex;
    USHORT *        pusRegInputBuf;
    USHORT          REG_INPUT_START;
    USHORT          REG_INPUT_NREGS;
    USHORT          usRegInStart;
    //todo переписать с использованием очереди
    SHORT   usSRegInStart                               = S_REG_INPUT_START;
    USHORT  usSRegInBuf[S_REG_INPUT_NREGS]              = {10,20,30,40,50,60,70,80,90,100};


    pusRegInputBuf = usSRegInBuf;
    REG_INPUT_START = S_REG_INPUT_START;
    REG_INPUT_NREGS = S_REG_INPUT_NREGS;
    usRegInStart = usSRegInStart;

    /* it already plus one in modbus function method. */
    usAddress--;

    if ((usAddress >= REG_INPUT_START) && (usAddress + usNRegs <= REG_INPUT_START + REG_INPUT_NREGS))
    {
    	//xQueuePeek(discreteInputsQ, &Input_status, 0); // получаем состояние входов

		//for (int i = 0; i < usNRegs; i++) {
		//	UCHAR rbit = xMBUtilGetBits( &Input_status, usAddress+i, 1 );
		//	xMBUtilSetBits( pucRegBuffer, i, 1, rbit );
		//}

        iRegIndex = usAddress - usRegInStart;
        while (usNRegs > 0)
        {
            *pucRegBuffer++ = (UCHAR) (pusRegInputBuf[iRegIndex] >> 8);
            *pucRegBuffer++ = (UCHAR) (pusRegInputBuf[iRegIndex] & 0xFF);
            iRegIndex++;
            usNRegs--;
        }
    }
    else
    {
        eStatus = MB_ENOREG;
    }

    return eStatus;
}


/**
**===========================================================================
**
**  Abstract: main program
**
**===========================================================================
*/
int main(void)
{

  /**
  *  IMPORTANT NOTE!
  *  The symbol VECT_TAB_SRAM needs to be defined when building the project
  *  if code has been located to RAM and interrupts are used. 
  *  Otherwise the interrupt table located in flash will be used.
  *  See also the <system_*.c> file and how the SystemInit() function updates 
  *  SCB->VTOR register.  
  *  E.g.  SCB->VTOR = 0x20000000;  
  **/

  /* TODO - Add your application code here */
	__disable_irq();
	 NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x08010000);
	__enable_irq();

	ConfigRcc();
	ConfigGPIO();
	ConfigSPI2();
	SPI_flash_io_init();

	/* --------------------init queue ---------------------------*/
	runnTimeQ 				= xQueueCreate ( QUEUE_LENGTH, sizeof(uint32_t));
	EthernetInfoQ 			= xQueueCreate ( QUEUE_LENGTH, sizeof(Ethernet_info_struct));
	bootCountQ				= xQueueCreate ( QUEUE_LENGTH, sizeof(uint32_t));
	discreteInputsQ 		= xQueueCreate ( QUEUE_LENGTH, sizeof(uint8_t));
	disctereOutputsReadQ 	= xQueueCreate ( QUEUE_LENGTH, sizeof(uint8_t));
	disctereOutputsWriteQ	= xQueueCreate ( QUEUE_LENGTH, sizeof(uint8_t));
	MQTTCredQ 				= xQueueCreate ( QUEUE_LENGTH, sizeof(MQTT_cred_struct));
	HAParamsQ				= xQueueCreate ( QUEUE_LENGTH, sizeof(Home_assist_struct));
	ModbusTCPparamsQ		= xQueueCreate ( QUEUE_LENGTH, sizeof(ModBusTCP_struct));
	/* --------------------init mutex ---------------------------*/
	SPI2mutex 				= xSemaphoreCreateMutex();
	LFSmutex 				= xSemaphoreCreateMutex();
	SocketMutex				= xSemaphoreCreateMutex();
	DNSMutex				= xSemaphoreCreateMutex();
	xSemaphoreGive(SPI2mutex);
	xSemaphoreGive(LFSmutex);
	xSemaphoreGive(SocketMutex);
	xSemaphoreGive(DNSMutex);
	RegSPIMutexCallbackFunction(SPI2TakeSemaphore, SPI2GiveSemaphore);

	sFLASH_GetInfo();

	xTaskCreate(vRead_and_write_settings		,(const char*)"vRead_and_write_settings"  		 , 1000, NULL, tskIDLE_PRIORITY + 2, &RW_settings	);
	xTaskCreate(vOneSecondTikTask				,(const char*)"vOneSecondTikTask"		   		 , 150,  NULL, tskIDLE_PRIORITY + 1, &OneSecond		);
	xTaskCreate(vCol_and_Input					,(const char*)"vCol_and_Input"			   		 , 200,  NULL, tskIDLE_PRIORITY + 1, &Col_and_Input	);
	xTaskCreate(vInternetMainTask				,(const char*)"vInternetMainTask"				 , 2000, NULL, tskIDLE_PRIORITY + 2, &Internet		);
	xTaskCreate(vInternetModbusTCP				,(const char*)"vInternetModbusTCP"			   	 , 700,  NULL, tskIDLE_PRIORITY + 1, &Internet_modbus );
	xTaskCreate(vInternetHTTPd					,(const char*)"vInternetHTTPd"			   		 , 5000, NULL, tskIDLE_PRIORITY + 1, &Internet_httpd );
	xTaskCreate(vInternet_MQTT					,(const char*)"vInternet_MQTT"				   	 , 1500, NULL, tskIDLE_PRIORITY + 1, &Internet_MQTT	);
	xTaskCreate(vDebug_RAM_usage				,(const char*)"vDebug_RAM_usage"				 , 70,  NULL, tskIDLE_PRIORITY + 1, &RAM_debug_task_handler );
	vTaskStartScheduler();
}


